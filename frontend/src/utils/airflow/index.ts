import type { Node, Edge } from '@xyflow/react';
import type { DagTaskNodeData, DagConfig } from '../../types';
import { generateDefaultArgs, generateSchedule } from './helpers';
import { generateImports } from './imports';
import { generateTaskCode } from './operators';
import { generateDependencies } from './dependencies';

export interface AirflowCodeResult {
  code: string;
  errors: string[];
}

// Main code generation function
export const generateAirflowCode = (
  tasks: Node<DagTaskNodeData>[],
  edges: Edge[],
  config: DagConfig
): AirflowCodeResult => {
  const errors: string[] = [];
  const lines: string[] = [];

  // Validate inputs
  if (!config.dagId) {
    errors.push('DAG ID is required');
  }

  if (tasks.length === 0) {
    errors.push('No tasks defined in the DAG');
  }

  // Check for unconfigured tasks
  tasks.forEach(task => {
    if (!task.data.configured) {
      errors.push(`Task "${task.data.label}" is not configured`);
    }
  });

  // Generate file header
  lines.push('"""');
  lines.push(`Airflow DAG: ${config.dagId}`);
  lines.push(`Description: ${config.description || 'Auto-generated DAG'}`);
  lines.push('');
  lines.push('Generated by ETLab');
  lines.push(`Generated at: ${new Date().toISOString()}`);
  lines.push('"""');
  lines.push('');

  // Generate imports
  lines.push(...generateImports(tasks));
  lines.push('');

  // Generate default_args
  lines.push(...generateDefaultArgs(config));
  lines.push('');

  // Generate DAG definition
  lines.push('# DAG definition');
  lines.push(`with DAG(`);
  lines.push(`    dag_id="${config.dagId}",`);
  lines.push(`    default_args=default_args,`);
  lines.push(`    description="${config.description || ''}",`);
  lines.push(`    schedule=${generateSchedule(config)},`);
  lines.push(`    start_date=datetime(${new Date().getFullYear()}, 1, 1),`);
  lines.push(`    catchup=${config.catchup ? 'True' : 'False'},`);
  lines.push(`    max_active_runs=${config.maxActiveRuns},`);
  if (config.tags.length > 0) {
    lines.push(`    tags=${JSON.stringify(config.tags)},`);
  }
  lines.push(`) as dag:`);
  lines.push('');

  // Generate task definitions
  tasks.forEach(task => {
    lines.push(...generateTaskCode(task));
  });

  // Generate dependencies
  lines.push(...generateDependencies(tasks, edges));

  return {
    code: lines.join('\n'),
    errors,
  };
};

// Export helper functions for testing
export { toTaskId, generateDefaultArgs } from './helpers';
export { generateImports, generateImports as generateAirflowImports } from './imports';
export { generateTaskCode } from './operators';
export { generateDependencies } from './dependencies';
