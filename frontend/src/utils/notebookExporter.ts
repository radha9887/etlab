/**
 * Jupyter Notebook Exporter Utility
 * Converts CodeCells from PySpark generator to Jupyter .ipynb format
 */

import type { CodeCell } from './pyspark';

// Jupyter Notebook types
interface NotebookCell {
  cell_type: 'code' | 'markdown';
  metadata: {
    category?: string;
    nodeId?: string;
    [key: string]: any;
  };
  source: string[];
  id: string;
  outputs?: any[];
  execution_count?: number | null;
}

interface NotebookMetadata {
  kernelspec: {
    display_name: string;
    language: string;
    name: string;
  };
  language_info: {
    name: string;
    version: string;
    codemirror_mode?: {
      name: string;
      version: number;
    };
    file_extension?: string;
    mimetype?: string;
    pygments_lexer?: string;
  };
  etlab?: {
    version: string;
    generated_at: string;
    source_page?: string;
  };
}

interface JupyterNotebook {
  nbformat: number;
  nbformat_minor: number;
  metadata: NotebookMetadata;
  cells: NotebookCell[];
}

/**
 * Get category icon/emoji for markdown headers
 */
const getCategoryEmoji = (category?: string): string => {
  switch (category) {
    case 'imports': return 'ðŸ“¦';
    case 'source': return 'ðŸ“‚';
    case 'transform': return 'ðŸ”„';
    case 'sink': return 'ðŸ’¾';
    case 'action': return 'â–¶ï¸';
    case 'footer': return 'ðŸ';
    default: return 'ðŸ“';
  }
};

/**
 * Get category display name
 */
const getCategoryName = (category?: string): string => {
  switch (category) {
    case 'imports': return 'Setup & Imports';
    case 'source': return 'Data Source';
    case 'transform': return 'Transformation';
    case 'sink': return 'Data Sink';
    case 'action': return 'Action';
    case 'footer': return 'Cleanup';
    default: return 'Code';
  }
};

/**
 * Generate a unique cell ID
 */
const generateCellId = (): string => {
  return Math.random().toString(36).substring(2, 15);
};

/**
 * Convert a CodeCell to a Jupyter notebook cell
 */
const convertToNotebookCell = (cell: CodeCell, includeMarkdownHeaders: boolean): NotebookCell[] => {
  const cells: NotebookCell[] = [];

  // Add markdown header cell if enabled
  if (includeMarkdownHeaders && cell.title) {
    const emoji = getCategoryEmoji(cell.category);
    const categoryName = getCategoryName(cell.category);

    cells.push({
      cell_type: 'markdown',
      metadata: {},
      source: [`## ${emoji} ${cell.title}\n`, `*${categoryName}*`],
      id: generateCellId(),
    });
  }

  // Add the code cell
  const codeCell: NotebookCell = {
    cell_type: cell.cellType === 'markdown' ? 'markdown' : 'code',
    metadata: {
      category: cell.category,
      nodeId: cell.nodeId,
    },
    source: cell.code.split('\n').map((line, idx, arr) =>
      idx === arr.length - 1 ? line : line + '\n'
    ),
    id: cell.id || generateCellId(),
  };

  // Add code-specific properties
  if (codeCell.cell_type === 'code') {
    codeCell.outputs = [];
    codeCell.execution_count = null;
  }

  cells.push(codeCell);

  return cells;
};

/**
 * Convert CodeCells array to Jupyter Notebook JSON
 */
export const generateJupyterNotebook = (
  cells: CodeCell[],
  options?: {
    pageName?: string;
    includeMarkdownHeaders?: boolean;
  }
): JupyterNotebook => {
  const { pageName = 'ETL Pipeline', includeMarkdownHeaders = true } = options || {};

  const notebookCells: NotebookCell[] = [];

  // Add title cell
  notebookCells.push({
    cell_type: 'markdown',
    metadata: {},
    source: [
      `# ${pageName}\n`,
      '\n',
      `Generated by ETLab on ${new Date().toLocaleString()}\n`,
      '\n',
      '---'
    ],
    id: generateCellId(),
  });

  // Convert each CodeCell to notebook cells
  cells.forEach(cell => {
    const converted = convertToNotebookCell(cell, includeMarkdownHeaders);
    notebookCells.push(...converted);
  });

  return {
    nbformat: 4,
    nbformat_minor: 5,
    metadata: {
      kernelspec: {
        display_name: 'Python 3 (ipykernel)',
        language: 'python',
        name: 'python3',
      },
      language_info: {
        name: 'python',
        version: '3.10.0',
        codemirror_mode: {
          name: 'ipython',
          version: 3,
        },
        file_extension: '.py',
        mimetype: 'text/x-python',
        pygments_lexer: 'ipython3',
      },
      etlab: {
        version: '1.0.0',
        generated_at: new Date().toISOString(),
        source_page: pageName,
      },
    },
    cells: notebookCells,
  };
};

/**
 * Export notebook as .ipynb file (triggers download)
 */
export const exportNotebook = (
  cells: CodeCell[],
  filename: string,
  options?: {
    includeMarkdownHeaders?: boolean;
  }
): void => {
  const notebook = generateJupyterNotebook(cells, {
    pageName: filename,
    ...options,
  });

  const jsonString = JSON.stringify(notebook, null, 2);
  const blob = new Blob([jsonString], { type: 'application/x-ipynb+json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `${filename.replace(/\s+/g, '_').toLowerCase()}.ipynb`;
  a.click();

  URL.revokeObjectURL(url);
};

/**
 * Export notebook as HTML (for sharing without Jupyter)
 */
export const exportNotebookAsHtml = (
  cells: CodeCell[],
  filename: string
): void => {
  const html = generateNotebookHtml(cells, filename);
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `${filename.replace(/\s+/g, '_').toLowerCase()}.html`;
  a.click();

  URL.revokeObjectURL(url);
};

/**
 * Generate HTML representation of notebook
 */
const generateNotebookHtml = (cells: CodeCell[], title: string): string => {
  const cellsHtml = cells.map((cell, idx) => {
    const emoji = getCategoryEmoji(cell.category);
    const escapedCode = cell.code
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

    return `
      <div class="cell">
        <div class="cell-header">
          <span class="cell-number">[${idx + 1}]</span>
          <span class="cell-title">${emoji} ${cell.title}</span>
        </div>
        <pre class="cell-code"><code>${escapedCode}</code></pre>
      </div>
    `;
  }).join('\n');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title} - ETLab Notebook</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      color: #00d4ff;
      border-bottom: 2px solid #00d4ff;
      padding-bottom: 10px;
    }
    .cell {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      margin: 16px 0;
      overflow: hidden;
    }
    .cell-header {
      background: #0f3460;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cell-number {
      color: #888;
      font-family: monospace;
      font-size: 12px;
    }
    .cell-title {
      font-weight: 500;
      color: #00d4ff;
    }
    .cell-code {
      margin: 0;
      padding: 16px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    .cell-code code {
      font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
    }
    .footer {
      text-align: center;
      color: #666;
      margin-top: 40px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>${title}</h1>
  <p style="color: #888;">Generated by ETLab on ${new Date().toLocaleString()}</p>
  ${cellsHtml}
  <div class="footer">
    Generated by ETLab
  </div>
</body>
</html>`;
};
