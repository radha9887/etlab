/**
 * Tests for Jupyter Notebook Exporter
 */
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import type { CodeCell } from '../pyspark'
import { generateJupyterNotebook } from '../notebookExporter'

// Helper to create CodeCell
const createCodeCell = (
  id: string,
  code: string,
  title: string,
  category?: string,
  nodeId?: string
): CodeCell => ({
  id,
  code,
  title,
  category: category as any,
  nodeId,
  cellType: 'code',
})

describe('Notebook Exporter', () => {
  describe('generateJupyterNotebook', () => {
    it('generates valid notebook structure', () => {
      const cells: CodeCell[] = []
      const notebook = generateJupyterNotebook(cells)

      expect(notebook.nbformat).toBe(4)
      expect(notebook.nbformat_minor).toBe(5)
      expect(notebook.metadata).toBeDefined()
      expect(notebook.cells).toBeDefined()
    })

    it('includes correct kernel specification', () => {
      const cells: CodeCell[] = []
      const notebook = generateJupyterNotebook(cells)

      expect(notebook.metadata.kernelspec).toEqual({
        display_name: 'Python 3 (ipykernel)',
        language: 'python',
        name: 'python3',
      })
    })

    it('includes correct language info', () => {
      const cells: CodeCell[] = []
      const notebook = generateJupyterNotebook(cells)

      expect(notebook.metadata.language_info.name).toBe('python')
      expect(notebook.metadata.language_info.version).toBe('3.10.0')
      expect(notebook.metadata.language_info.file_extension).toBe('.py')
    })

    it('includes ETLab metadata', () => {
      const cells: CodeCell[] = []
      const notebook = generateJupyterNotebook(cells, { pageName: 'My Pipeline' })

      expect(notebook.metadata.etlab).toBeDefined()
      expect(notebook.metadata.etlab?.version).toBe('1.0.0')
      expect(notebook.metadata.etlab?.source_page).toBe('My Pipeline')
      expect(notebook.metadata.etlab?.generated_at).toBeDefined()
    })

    it('generates title cell', () => {
      const cells: CodeCell[] = []
      const notebook = generateJupyterNotebook(cells, { pageName: 'Test Pipeline' })

      // First cell should be title
      const titleCell = notebook.cells[0]
      expect(titleCell.cell_type).toBe('markdown')
      expect(titleCell.source.join('')).toContain('# Test Pipeline')
      expect(titleCell.source.join('')).toContain('Generated by ETLab')
    })

    it('converts CodeCell to notebook cells', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'print("hello")', 'Print Hello', 'action'),
      ]
      const notebook = generateJupyterNotebook(cells)

      // Should have title + markdown header + code cell
      expect(notebook.cells.length).toBeGreaterThan(1)

      const codeCells = notebook.cells.filter(c => c.cell_type === 'code')
      expect(codeCells.length).toBe(1)
      expect(codeCells[0].source.join('')).toContain('print("hello")')
    })

    it('adds markdown headers when enabled', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'df = spark.read.csv("data.csv")', 'Load CSV', 'source'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: true,
      })

      const markdownCells = notebook.cells.filter(c => c.cell_type === 'markdown')
      // Should have title + header for the code cell
      expect(markdownCells.length).toBeGreaterThanOrEqual(2)

      const headerCell = markdownCells.find(c =>
        c.source.join('').includes('Load CSV')
      )
      expect(headerCell).toBeDefined()
    })

    it('skips markdown headers when disabled', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'df = spark.read.csv("data.csv")', 'Load CSV', 'source'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const markdownCells = notebook.cells.filter(c => c.cell_type === 'markdown')
      // Should only have title cell
      expect(markdownCells.length).toBe(1)
    })

    it('preserves cell metadata', () => {
      const cells: CodeCell[] = [
        createCodeCell('cell-1', 'x = 1', 'Set X', 'transform', 'node-123'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.metadata.category).toBe('transform')
      expect(codeCell?.metadata.nodeId).toBe('node-123')
    })

    it('generates correct cell IDs', () => {
      const cells: CodeCell[] = [
        createCodeCell('my-id', 'x = 1', 'Set X', 'transform'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.id).toBe('my-id')
    })

    it('code cells have outputs array', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'print("test")', 'Print', 'action'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.outputs).toEqual([])
      expect(codeCell?.execution_count).toBeNull()
    })

    it('splits code into lines with newlines preserved', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'x = 1\ny = 2\nz = 3', 'Variables', 'transform'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.source).toEqual(['x = 1\n', 'y = 2\n', 'z = 3'])
    })

    it('handles multiple cells', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'import pyspark', 'Imports', 'imports'),
        createCodeCell('2', 'df = spark.read.csv("data.csv")', 'Load Data', 'source'),
        createCodeCell('3', 'df = df.filter("col > 0")', 'Filter', 'transform'),
        createCodeCell('4', 'df.write.parquet("output")', 'Save', 'sink'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCells = notebook.cells.filter(c => c.cell_type === 'code')
      expect(codeCells.length).toBe(4)
    })

    it('uses default page name', () => {
      const cells: CodeCell[] = []
      const notebook = generateJupyterNotebook(cells)

      const titleCell = notebook.cells[0]
      expect(titleCell.source.join('')).toContain('# ETL Pipeline')
    })

    it('handles cells without title', () => {
      const cells: CodeCell[] = [
        {
          id: '1',
          code: 'x = 1',
          title: '',
          category: 'transform',
          cellType: 'code',
        },
      ]

      // Should not throw
      const notebook = generateJupyterNotebook(cells)
      expect(notebook.cells.length).toBeGreaterThan(0)
    })

    it('includes category emoji in markdown headers', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', 'import spark', 'Setup', 'imports'),
        createCodeCell('2', 'df = spark.read', 'Load', 'source'),
        createCodeCell('3', 'df = df.filter()', 'Filter', 'transform'),
        createCodeCell('4', 'df.write', 'Save', 'sink'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: true,
      })

      const markdownCells = notebook.cells.filter(c => c.cell_type === 'markdown')
      const headers = markdownCells.map(c => c.source.join(''))

      // Check emojis are present
      expect(headers.some(h => h.includes('ðŸ“¦'))).toBe(true) // imports
      expect(headers.some(h => h.includes('ðŸ“‚'))).toBe(true) // source
      expect(headers.some(h => h.includes('ðŸ”„'))).toBe(true) // transform
      expect(headers.some(h => h.includes('ðŸ’¾'))).toBe(true) // sink
    })
  })

  describe('Edge cases', () => {
    it('handles empty code', () => {
      const cells: CodeCell[] = [createCodeCell('1', '', 'Empty Cell', 'transform')]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.source).toEqual([''])
    })

    it('handles code with special characters', () => {
      const cells: CodeCell[] = [
        createCodeCell(
          '1',
          'df.filter("col > 10 && col < 20")',
          'Filter',
          'transform'
        ),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.source.join('')).toContain('&&')
    })

    it('handles code with unicode', () => {
      const cells: CodeCell[] = [
        createCodeCell('1', '# æ—¥æœ¬èªžã‚³ãƒ¡ãƒ³ãƒˆ\nx = "ãƒ†ã‚¹ãƒˆ"', 'Unicode', 'transform'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.source.join('')).toContain('æ—¥æœ¬èªž')
    })

    it('handles very long code', () => {
      const longCode = 'x = ' + 'a'.repeat(10000)
      const cells: CodeCell[] = [
        createCodeCell('1', longCode, 'Long Code', 'transform'),
      ]
      const notebook = generateJupyterNotebook(cells, {
        includeMarkdownHeaders: false,
      })

      const codeCell = notebook.cells.find(c => c.cell_type === 'code')
      expect(codeCell?.source.join('')).toContain('a'.repeat(100))
    })
  })
})
